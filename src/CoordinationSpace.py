# Takes as input the obstacles and trajectory of a robot from the MSL library
# http://msl.cs.uiuc.edu/msl/

# Determines which sections of a trajectory require human supervision based on
# -change in angle
# -change in speed
# -proximity to static obstacles
# -proximity to dynamic obstacles or other robots
# Outputs a Timing Function that prohibits robots from colliding with one another,
# and allows a human supervisor to monitor only one robot at a time

import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # @UnresolvedImport @UnusedImport

### Input Parameters ###
# Input files
obstacleFilename = '2robotObstacles.txt'  # obstacles generated by MSL (remove trailing empty lines)
policyFilename = '2robotPolicies.txt'  # policy generated by MSL

# Robot parameters
robotSize = 1  # radius of robots

# Human supervisor parameters
maxAngle = 1  # maximum "safe" change in orientation
maxAcceleration = 1  # maximum "safe" change in velocity
minDistance = 2  # minimum "safe" distance to obstacles or robots
supervisors = -1  # maximum number of available human supervisors, set as negative to disable

### Global Variables ###

# Obstacles
obstacles = []

# Robots
# Each robot is represented by a trajectory
# Each trajectory is composed of a series of states
# Each state is composed of ([0] velocity, [1] x-coordinate, [2] y-coordinate, [3] orientation [0-2pi),
# [4] safety (0-safe, 1-unsafe
robots = []

# Coordination space
cSpace = []

### Functions ###

# Read files and split data by line
def readFile (filename):
    info = []
    with open(filename, 'r') as openFile:
        data = openFile.readlines()
        for line in data:
            info.append(line.split())
    return info

# Extract obstacles
def extractObstacles(info):
    # Each obstacle is a set of points on a line
    for line in info:
        points = []
        # Iterate over all points and add them to an array representing the obstacle
        for endpoint in line:
            point = []
            x, y = map(float, endpoint.strip('()').split(','))
            point.append(float(x))
            point.append(float(y))
            points.append(point)
        obstacles.append(points)

# Distance from point to line
# Follows steps outlined in: http://paulbourke.net/geometry/pointlineplane/
def distancePointLine (x3, y3, x1, y1, x2, y2):
    px = x2 - x1
    py = y2 - y1

    distLine = px * px + py * py

    u = ((x3 - x1) * px + (y3 - y1) * py) / float(distLine)

    if u < 0:
        u = 0
    elif u > 1:
        u = 1

    x = x1 + u * px
    y = y1 + u * py

    return math.sqrt((x - x3) * (x - x3) + (y - y3) * (y - y3))

# Check safety of a given state given: previous and current velocities, current x and y, previous and current angles
def checkSafety(vp, vc, xc, yc, ap, ac):
    # Check distance to static obstacles
    for polygon in obstacles:  # Compare robot against each obstacle
        # Check from first point to end ("closing" the polygon)
        x1 = polygon[-1][0]
        y1 = polygon[-1][1]
        # Iterate over every point composing the polygon, drawing a line between each 2 points
        for i in polygon:
            x2 = i[0]
            y2 = i[1]
            if distancePointLine(xc, yc, x1, y1, x2, y2) < minDistance:
                return 1
            x1 = x2
            y1 = y2

    # Check change in velocity
    if abs(vc - vp) > maxAcceleration:
        return 1

    # Check change in angle
    if min(ac - ap, ap - ac) > maxAngle:
        return 1

    return 0

# Extract policy of each robot
def extractPolicies(info):
    for line in info:
        vs = line[0::4]  # velocities (every 4th element starting from 0)
        vs = [float(i) for i in vs]
        xs = line[1::4]  # x-coordinates (every 4th element starting from 1)
        xs = [float(i) for i in xs]
        ys = line[2::4]  # y-coordinates (every 4th element starting from 2)
        ys = [float(i) for i in ys]
        thetas = line[3::4]  # angles (every 4th element starting from 3)
        thetas = [float(i) for i in thetas]

        trajectory = []
        state = [vs[0], xs[0], ys[0], thetas[0], True]  # Assemble initial safe state
        trajectory.append(state)

        for i in xrange(1, len(vs)):  # Iterate over all other cases
            safety = checkSafety(vs[i - 1], vs[i], xs[i], ys[i], thetas[i - 1], thetas[i])  # Check safety of state
            state = [vs[i], xs[i], ys[i], thetas[i], safety]  # Assemble each state
            trajectory.append(state)  # Append to create trajectory for each robot
        robots.append(trajectory)  # Add each robot trajectory to list of robots

# Define Coordination Space
def createMatrix():
    # Array holding the size of each dimension (given by number of states for each robot)
    n = []
    for robot in robots:
        n.append(len(robot))
    return createCoordinationSpace(n, 0, [])

# Recursively build n-dimensional array of ints, which represents the Coordination Space
# Input parameters are:
# n (array representing the size of each dimension),
# depth (the current dimension being generated)
# configuration (array representing the current set of states being generated/evaluated)
def createCoordinationSpace(n, depth, configuration):
    # Base case
    # Create the "last" dimensions for the nth robot
    # 0 if no collision, 1 if any robot in that state collides with any other robot in the same state
    if depth == len(n) - 1:
        array = []
        for i in xrange(0, n[depth]):
            configuration.append(i)
            # s = state, given by the position in configuration;
            collision = False
            # Check all collisions in the current state
            humans = supervisors
            for A1 in xrange(len(configuration)):  # Loop through all states of robots A1, A2
                if collision == False:  # Prevent unnecessary loops
                    for A2 in xrange(A1 + 1, len(configuration)):
                        if checkSupervision(A1, configuration[A1], A2, configuration[A2]):
                            humans -= 1
                        if checkCollisions(A1, configuration[A1], A2, configuration[A2]) or (humans < 0 and supervisors >= 0):
                            collision = True
            if collision:
                array.append(1)
            else:
                array.append(0)
            configuration.pop()
        return array

    # Recursive case
    else:
        array = []
        # Recursively call function for each element in each dimension
        for i in xrange(0, n[depth]):
            # Add current dimension being generated to configuration
            configuration.append(i)
            array.append(createCoordinationSpace(n, depth + 1, configuration))
            configuration.pop()
        return array

def checkSupervision(A1, s1, A2, s2):
# Check if two robots require supervision at the same time
    if robots[A1][s1][4] == 1 and robots[A2][s2][4] == 1:
        return True
    else:
        return False

# Check for collisions between two robots
def checkCollisions(A1, s1, A2, s2):
    # Treats each robot as a circle, and checks for an overlap between two circles
    # (distance between circles is less than 2r)
    if ((robots[A1][s1][1] - robots[A2][s2][1]) ** 2 +
        (robots[A1][s1][2] - robots[A2][s2][2]) ** 2) ** 0.5 < 2 * robotSize:
        return True
    else:
        return False

# Plot the trajectories of each robot
def plotPaths():
    # Iterate over every state of every robot
    for idx, robot in enumerate(robots):
        xs = []
        ys = []
        for state in robot:
            xs.append(state[1])
            ys.append(state[2])
        plt.plot(xs, ys, label='Robot: ' + str(idx))

    # Iterate over every point in every obstacle
    for polygon in obstacles:
        polygon.append(polygon[0])
        xs = []
        ys = []
        for i in xrange(len(polygon)):
            xs.append(polygon[i][0])
            ys.append(polygon[i][1])
        plt.plot(xs, ys)

    plt.suptitle('Paths')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.legend()
    plt.show()

# Plot the 2D Coordination Space
def plot2DCoordinationSpace():
    xs = []
    ys = []

    # Iterate over every combination of states in Coordination Space
    for x in xrange(len(cSpace)):
        for y in xrange(len(cSpace[0])):
            if cSpace[x][y] == 1:
                xs.append(x)
                ys.append(y)

    plt.scatter(xs, ys)
    plt.xlim([0, len(cSpace)])
    plt.ylim([0, len(cSpace[0])])

    plt.suptitle('2D Coordination Space')
    plt.xlabel('Robot 1')
    plt.ylabel('Robot 2')
    plt.show()

# Plot the 3D Coordination Space
def plot3DCoordinationSpace():
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')

    xs = []
    ys = []
    zs = []

    # Iterate over every combination of states in Coordination Space
    for x in xrange(len(cSpace)):
        for y in xrange(len(cSpace[x])):
            for z in xrange(len(cSpace[x][y])):
                if cSpace[x][y][z] == 1:
                    xs.append(x)
                    ys.append(y)
                    zs.append(z)

    ax.scatter(xs, ys, zs)
    ax.set_xlim3d(0, len(cSpace))
    ax.set_ylim3d(0, len(cSpace[0]))
    ax.set_zlim3d(0, len(cSpace[0][0]))

    plt.suptitle('3D Coordination Space')
    xLabel = ax.set_xlabel('Robot 1')
    yLabel = ax.set_ylabel('Robot 2')
    zLabel = ax.set_zlabel('Robot 3')
    plt.show()

def plotCSpace():
    if len(robots) == 2:
        plot2DCoordinationSpace()
    elif len(robots) == 3:
        plot3DCoordinationSpace()

# Print a 2D view of Configuration Space Matrix
def printCSpace():
    for i in cSpace:
        print i

### Required Function Calls ####
extractObstacles(readFile(obstacleFilename))
extractPolicies(readFile(policyFilename))
cSpace = createMatrix()

### Optional Function Calls Here ###
plotPaths()
plotCSpace()

### Debug Function Calls Here ###
# printCSpace()
