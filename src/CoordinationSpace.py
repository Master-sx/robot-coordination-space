# Takes as input the obstacles and trajectory of a robot from the MSL library
# http://msl.cs.uiuc.edu/msl/
import numpy as np
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # @UnresolvedImport @UnusedImport
from heapq import heappush, heappop  # for priority queue

### Input Parameters ###
obstacleFilename = '2robots1humanObstacles.txt'  # obstacles generated by MSL (remove trailing empty lines)
policyFilename = '2robots1humanPolicies.txt'  # policy generated by MSL
robotSize = 1  # radius of robots, assumes robots are circular

### Global Variables ###

# Obstacles
obstacles = []

# Robots
# Each robot is represented by a trajectory
# Each trajectory is composed of a series of states
# Each state is composed of ([0] velocity, [1] x-coordinate, [2] y-coordinate, [4] orientation [0-2pi)
robots = []

# Coordination space
cSpace = []

### Functions ###

# Read files and split data by line
def readFile (filename):
    info = []
    with open(filename, 'r') as openFile:
        data = openFile.readlines()
        for line in data:
            info.append(line.split())
    return info

# Extract obstacles
def extractObstacles(info):
    # Each obstacle is a set of points on a line
    for line in info:
        points = []
        # Iterate over all points and add them to an array representing the obstacle
        for endpoint in line:
            point = []
            x, y = map(float, endpoint.strip('()').split(','))
            point.append(float(x))
            point.append(float(y))
            points.append(point)
        obstacles.append(points)

# Extract policy of each robot
def extractPolicies(info):
    for line in info:
        vs = line[0::4]  # velocities (every 4th element starting from 0)
        vs = [float(i) for i in vs]
        xs = line[1::4]  # x-coordinates (every 4th element starting from 1)
        xs = [float(i) for i in xs]
        ys = line[2::4]  # y-coordinates (every 4th element starting from 2)
        ys = [float(i) for i in ys]
        thetas = line[3::4]  # angles (every 4th element starting from 3)
        thetas = [float(i) for i in thetas]

        trajectory = []
        state = [vs[0], xs[0], ys[0], thetas[0], True]  # Assemble initial safe state
        trajectory.append(state)

        for i in range(1, len(vs)):  # Iterate over all other cases
            state = [vs[i], xs[i], ys[i], thetas[i]]  # Assemble each state
            trajectory.append(state)  # Append to create trajectory for each robot
        robots.append(trajectory)  # Add each robot trajectory to list of robots

# Define Coordination Space
def createMatrix():
    # Array holding the size of each dimension (given by number of states for each robot)
    n = []
    for robot in robots:
        n.append(len(robot))
    return createCoordinationSpace(n, 0, [])

# Recursively build n-dimensional array of ints, which represents the Coordination Space
# Input parameters are:
# n (array representing the size of each dimension),
# depth (the current dimension being generated)
# configuration (array representing the current set of states being generated/evaluated)
def createCoordinationSpace(n, depth, configuration):
    # Base case
    # Create the "last" dimensions for the nth robot
    # 0 if no collision, 1 if any robot in that state collides with any other robot in the same state
    if depth == len(n) - 1:
        array = []
        for i in xrange(0, n[depth]):
            configuration.append(i)
            # s = state, given by the position in configuration;
            collision = False
            # Check all collisions in the current state
            for A1 in range(len(configuration)):  # Loop through all states of robots A1, A2
                if collision == False:  # Prevent unnecessary loops
                    for A2 in range(A1 + 1, len(configuration)):
                            if checkCollisions(A1, configuration[A1], A2, configuration[A2]):
                                collision = True
            if collision:
                array.append(1)
            else:
                array.append(0)
            configuration.pop()  # Remove configuration that was just checked
        return array

    # Recursive case
    else:
        array = []
        # Recursively call function for each element in each dimension
        for i in xrange(0, n[depth]):
            # Add current dimension being generated to configuration
            configuration.append(i)
            array.append(createCoordinationSpace(n, depth + 1, configuration))
            configuration.pop()
        return array

# Check for collisions between two robots
def checkCollisions(A1, s1, A2, s2):
    # Treats each robot as a circle, and checks for an overlap between two circles
    # (if distance between circles is less than 2r)
    if ((robots[A1][s1][1] - robots[A2][s2][1]) ** 2 +
        (robots[A1][s1][2] - robots[A2][s2][2]) ** 2) ** 0.5 < 2 * robotSize:
        return True
    else:
        return False

# Plot the trajectories of each robot
def plotPaths():
    # Iterate over every state of every robot
    for idx, robot in enumerate(robots):
        xs = []
        ys = []
        for state in robot:
            xs.append(state[1])
            ys.append(state[2])
        plt.plot(xs, ys, label='Robot: ' + str(idx))

    # Iterate over every point in every obstacle
    for polygon in obstacles:
        polygon.append(polygon[0])
        xs = []
        ys = []
        for i in range(len(polygon)):
            xs.append(polygon[i][0])
            ys.append(polygon[i][1])
        plt.plot(xs, ys)

    plt.suptitle('Paths')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.legend()
    plt.show()

# Plot the 2D Coordination Space
def plot2DCoordinationSpace():
    xs = []
    ys = []

    pathXs = []
    pathYs = []

    # Iterate over every combination of states in Coordination Space
    for x in range(len(cSpace)):
        for y in range(len(cSpace[0])):
            if cSpace[x][y] == 1:
                xs.append(x)
                ys.append(y)
            elif cSpace[x][y] == 2:
                pathXs.append(x)
                pathYs.append(y)

    plt.scatter(xs, ys, color='blue')
    plt.scatter(0, 0, color='red')
    plt.scatter(pathXs, pathYs, color='green')
    plt.scatter(len(cSpace) - 1, len(cSpace[0]) - 1, color='magenta')
    plt.xlim([0, len(cSpace)])
    plt.ylim([0, len(cSpace[0])])

    plt.suptitle('2D Coordination Space')
    plt.xlabel('Robot 1')
    plt.ylabel('Robot 2')
    plt.show()

# Plot the 3D Coordination Space
def plot3DCoordinationSpace():
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')

    xs = []
    ys = []
    zs = []

    xps = []
    yps = []
    zps = []

    # Iterate over every combination of states in Coordination Space
    for x in range(len(cSpace)):
        for y in range(len(cSpace[x])):
            for z in range(len(cSpace[x][y])):
                if cSpace[x][y][z] == 1:
                    xs.append(x)
                    ys.append(y)
                    zs.append(z)
                elif cSpace[x][y][z] == 2:
                    xps.append(x)
                    yps.append(y)
                    zps.append(z)

    ax.scatter(xs, ys, zs, color='blue')
    ax.scatter(0, 0, 0, color='green')
    ax.scatter(xps, yps, zps, color='red')
    ax.scatter(len(cSpace) - 1, len(cSpace[x]) - 1, len(cSpace[x][y]) - 1, color='cyan')
    ax.set_xlim3d(0, len(cSpace))
    ax.set_ylim3d(0, len(cSpace[0]))
    ax.set_zlim3d(0, len(cSpace[0][0]))

    plt.suptitle('3D Coordination Space')
    xLabel = ax.set_xlabel('Robot 1')
    yLabel = ax.set_ylabel('Robot 2')
    zLabel = ax.set_zlabel('Robot 3')
    plt.show()

# Print a 2D view of Configuration Space Matrix
def printCSpace():
    for i in cSpace:
        print i

def plotCSpace():
    if len(robots) == 2:
        plot2DCoordinationSpace()
    elif len(robots) == 3:
        plot3DCoordinationSpace()

# Return the length of the trajectory of a robot
def findTrajectoryLength(robot):
    trajectoryLength = 0
    prevX = robots[robot][0][1]
    prevY = robots[robot][0][2]

    # Iterate over all states and find the Euclidean distance between the two points
    # Return the sum of all of these distances
    for state in robots[robot]:  # This is going to check the 1st state against itself, which gives 0
        currX = state[1]
        currY = state[2]
        trajectoryLength += math.sqrt((currX - prevX) ** 2 + (currY - prevY) ** 2)
        prevX = currX
        prevY = currY
    return trajectoryLength

# TODO: this does a lot of the same work as findTrajectoryLength and can be combined
# TODO: this can also be combined with extractPolicies
def normalizeTrajectory(robot):
    time = 1  # Time interval between robot updates
    trajectoryLength = findTrajectoryLength(robot)

    # Interval length is given by floor of (length of trajectory / (robot speed * update interval time))
    intervals = math.floor(trajectoryLength / (robots[robot][0][0] * time))
    intervalLength = trajectoryLength / intervals  # length of each interval between updates
    distOldStates = 0
    distNewStates = 0

    prevX = robots[robot][0][1]
    prevY = robots[robot][0][2]

    newTrajectory = []

    for state in robots[robot]:
        currX = state[1]
        currY = state[2]
        distOldStates += math.sqrt((currX - prevX) ** 2 + (currY - prevY) ** 2)

        # For every state in robot trajectory, iterate
        # If distance between the current state and the start is larger than the
        # distance between the current normalized state and the start
        # then add the corresponding new state to the new normalized trajectory to "catch up" and
        # increase the distance of the new trajectory by one interval
        # then check again to see if another "new state" lies in the original interval
        while distOldStates > distNewStates:
            dX = currX - prevX
            dY = currY - prevY

            length = math.sqrt(dX ** 2 + dY ** 2)

            dX /= length
            dY /= length

            # Find the % of length that must be added to the new state starting from the last valid original state
            distance = distOldStates - distNewStates
            addDiff = length - distance

            dX *= addDiff
            dY *= addDiff

            newX = prevX + dX
            newY = prevY + dY

            newTrajectory.append([state[0], newX, newY, state[3]])
            distNewStates += intervalLength
        prevX = currX
        prevY = currY
    return newTrajectory

def normalizeAllTrajectories():
    for robot in range(len(robots)):
        robots[robot] = normalizeTrajectory(robot)

### Required Function Calls ####
extractObstacles(readFile(obstacleFilename))
extractPolicies(readFile(policyFilename))
normalizeAllTrajectories()
cSpace = createMatrix()

class node:
    xPos = 0  # x position
    yPos = 0  # y position
    zPos = 0
    parent = 0
    distance = 0  # total distance already travelled to reach the node
    priority = 0  # priority = distance + remaining distance estimate
    def __init__(self, xPos, yPos, zPos, distance, priority, parent):
        self.xPos = xPos
        self.yPos = yPos
        self.zPos = zPos
        self.distance = distance
        self.priority = priority
        self.parent = parent
    def __lt__(self, other):  # comparison method for priority queue
        return self.priority < other.priority
    def updatePriority(self, xDest, yDest, zDest):
        self.priority = self.distance + self.estimate(xDest, yDest, zDest)  # A*
    # give higher priority to going straight instead of diagonally
    def nextMove(self, dirs, d):  # d: direction to move
        if dirs == 26 and dirs % 2 != 0:
            self.distance += 14
        else:
            self.distance += 1
    # Estimation function for the remaining distance to the goal.
    def estimate(self, xDest, yDest, zDest):
        xd = xDest - self.xPos
        yd = yDest - self.yPos
        zd = zDest - self.zPos
        # Euclidian Distance
        d = math.sqrt(xd ** 2 + yd ** 2 + zd ** 2)
        return(d)

# A-star algorithm.
# The path returned will be a string of digits of directions.
def pathFind(the_map, n, m, o, dirs, dx, dy, dz, xA, yA, zA, xB, yB, zB):
    closed_nodes_map = []  # map of closed (tried-out) nodes
    open_nodes_map = []  # map of open (not-yet-tried) nodes
    dir_map = []  # map of dirs
    myMap = [[[0 for k in xrange(o)]for j in xrange(m)]for i in xrange(n)]
    closed_nodes_map = myMap
    open_nodes_map = myMap
    dir_map = myMap
    pq = [[], []]  # priority queues of open (not-yet-tried) nodes
    pqi = 0  # priority queue index
    # create the start node and push into list of open nodes
    n0 = node(xA, yA, zA, 0, 0, 0)
    n0.updatePriority(xB, yB, zB)
    heappush(pq[pqi], n0)
    open_nodes_map[xA][yA][zA] = n0.priority  # mark it on the open nodes map
    last_node = n0

    # A* search
    while len(pq[pqi]) > 0:  # priority/open queue is populated
        # get the current node w/ the highest priority
        # from the list of open nodes
        n1 = pq[pqi][0]  # top node
        n0 = node(n1.xPos, n1.yPos, n1.zPos, n1.distance, n1.priority, n1)
        x = n0.xPos
        y = n0.yPos
        z = n0.zPos

        heappop(pq[pqi])  # remove the node from the open list
        open_nodes_map[x][y][z] = 0
        closed_nodes_map[x][y][z] = 1  # mark it on the closed nodes map
        # quit searching when the goal is reached
        if x == xB and y == yB and z == zB:
            # generate the path from finish to start
            # by following the dirs
            while not (last_node.parent == 0):
                cSpace[last_node.xPos][last_node.yPos][last_node.zPos] = 2
                last_node = last_node.parent
            return "success"
        # generate moves (child nodes) in all possible dirs
        for i in range(dirs):
            xdx = x + dx[i]
            ydy = y + dy[i]
            zdz = z + dz[i]
            if not (xdx < 0 or xdx > n - 1 or ydy < 0 or ydy > m - 1 or zdz < 0 or zdz > o - 1
                    or the_map[xdx][ydy][zdz] == 1 or closed_nodes_map[xdx][ydy][zdz] == 1):
                # generate a child node
                m0 = node(xdx, ydy, zdz, n0.distance, n0.priority, n0)
                m0.nextMove(dirs, i)
                m0.updatePriority(xB, yB, zB)
                last_node = m0
                # if it is not in the open list then add into that
                if open_nodes_map[xdx][ydy][zdz] == 0:
                    open_nodes_map[xdx][ydy][zdz] = m0.priority
                    heappush(pq[pqi], m0)
                    # print "4- pq", pq
                    # mark its parent node direction
                    dir_map[xdx][ydy][zdz] = (i + dirs / 2) % dirs
                elif open_nodes_map[xdx][ydy][zdz] > m0.priority:
                    # update the priority
                    open_nodes_map[xdx][ydy][zdz] = m0.priority
                    # update the parent direction
                    dir_map[xdx][ydy][zdz] = (i + dirs / 2) % dirs

                    # replace the node
                    # by emptying one pq to the other one
                    # except the node to be replaced will be ignored
                    # and the new node will be pushed in instead
                    ###############################################ERR
                    while not (pq[pqi][0].xPos == xdx and pq[pqi][0].yPos == ydy and pq[pqi][0].zPos == zdz):
                        heappush(pq[1 - pqi], pq[pqi][0])
                        heappop(pq[pqi])
                    heappop(pq[pqi])  # remove the target node
                    # empty the larger size priority queue to the smaller one
                    if len(pq[pqi]) > len(pq[1 - pqi]):
                        pqi = 1 - pqi
                    while len(pq[pqi]) > 0:
                        heappush(pq[1 - pqi], pq[pqi][0])
                        heappop(pq[pqi])
                    pqi = 1 - pqi
                    heappush(pq[pqi], m0)  # add the better node instead
    return "failed"  # if no route found

# MAIN
dirs = 26  # number of possible directions to move on the map
dx = [-1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]
dy = [-1, -1, -1, 0, 0, 0, 1, 1, 1, -1, -1, -1, 0, 0, 1, 1, 1, -1, -1, -1, 0, 0, 0, 1, 1, 1]
dz = [-1, 0, 1, -1, 0, 1, -1, 0, 1, -1, 0, 1, -1, 1, -1, 0, 1, -1, 0, 1, -1, 0, 1, -1, 0, 1]

the_map = cSpace
dim = max(len(the_map[0][0]), len(the_map[0]), len(the_map))
n = len(the_map)
m = len(the_map[0])
o = len(the_map[0][0])
# select start and finish locations from a list
pathFind(the_map, n, m, o, dirs, dx, dy, dz, 0, 0, 0, n - 1, m - 1, o - 1)

### Optional Function Calls Here ###
plotPaths()
plotCSpace()

### Debug Function Calls Here ###
# printCSpace()
